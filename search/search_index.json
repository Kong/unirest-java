{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Unirest-Java Documentation","text":"<p>Welcome to Unirest-Java!</p>"},{"location":"#about","title":"About","text":"<p>Unirest is intended to be a simple and obvious library for HTTP requests. It provides a fluent interface that makes discovery of commands easy in a modern IDE. Some of the features it supports are:</p> <ul> <li>HTTP 1 and 2</li> <li>WebSockets</li> <li>JSON Patch (RFC-6902)</li> <li>Default Object mappers for both Jackson and GSON</li> <li>Easy request building including<ul> <li>Path parameters</li> <li>Query param building</li> <li>Headers including full suport for manipulating cookies</li> <li>Multipart requests</li> <li>Turning POJOs into string or binary bodies</li> <li>Global request interceptors</li> </ul> </li> <li>Easy response handling including<ul> <li>Global response interceptors</li> <li>Turning bodies into POJOs </li> <li>Error handling</li> </ul> </li> <li>Mocking library for testing</li> </ul>"},{"location":"#history","title":"History","text":"<p>Unirest-Java started off as just one of series of HTTP clients written in different languages which all conform to the same pattern. </p> <p>From the original Unirest-Java though Unirest-Java 3 the library was essentially a wrapper around the excellent Apache HTTP </p>"},{"location":"caching/","title":"Caching","text":"<p>Unirest offers a simple im memory response caching mechanism with a few options for entry expiration. This can be either be enabled with defaults, with expiration options or consumers may supply a custom cache backed by the cache of their choice. It is reccomended that in high load systems consumers back the cache with a dedicated cache implementation like EHCache or Guava.</p>"},{"location":"caching/#basic-cache","title":"Basic cache:","text":"<pre><code>     Unirest.config().cacheResponses(true);\n\n     //These 1st response will be cached in this case:\n     Unirest.get(\"https://somwhere\").asString();\n     Unirest.get(\"https://somwhere\").asString();\n</code></pre>"},{"location":"caching/#advanced-options","title":"Advanced Options:","text":"<p>You can use a builder to customize eviction rules:</p> <pre><code>   Unirest.config().cacheResponses(builder()\n               .depth(5) // Depth is the max number of entries cached\n               .maxAge(5, TimeUnit.MINUTES)); // Max age is how long the entry will be kept.\n</code></pre>"},{"location":"caching/#custom-caches","title":"Custom Caches","text":"<p>You can also supply a custom cache by implementing the Cache Interface <pre><code>    public static void main(String[] args){\n       Unirest.config().cacheResponses(Cache.builder().backingCache(new GuavaCache()));\n    }\n\n    // Example backing cache using Guava\n    public static class GuavaCache implements Cache {\n            com.google.common.cache.Cache&lt;Key, HttpResponse&gt; regular = CacheBuilder.newBuilder().build();\n            com.google.common.cache.Cache&lt;Key, CompletableFuture&gt; async = CacheBuilder.newBuilder().build();\n            @Override\n            public &lt;T&gt; HttpResponse get(Key key, Supplier&lt;HttpResponse&lt;T&gt;&gt; fetcher) {\n                try {\n                    return regular.get(key, fetcher::get);\n                } catch (ExecutionException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n\n            @Override\n            public &lt;T&gt; CompletableFuture getAsync(Key key, Supplier&lt;CompletableFuture&lt;HttpResponse&lt;T&gt;&gt;&gt; fetcher) {\n                try {\n                    return async.get(key, fetcher::get);\n                } catch (ExecutionException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n        }\n</code></pre></p>"},{"location":"configuration/","title":"Configuration","text":"<p>Previous versions of unirest had configuration split across several different places. Sometimes it was done on <code>Unirest</code>, sometimes it was done on <code>Option</code>, sometimes it was somewhere else. All configuration is now done through <code>Unirest.config()</code></p> <pre><code>    Unirest.config()\n           .connectTimeout(1000)\n           .proxy(new Proxy(\"https://proxy\"))\n           .setDefaultHeader(\"Accept\", \"application/json\")\n           .followRedirects(false)\n           .enableCookieManagement(false)\n           .addInterceptor(new MyCustomInterceptor());\n</code></pre> <p>Changing Unirest's config should ideally be done once, or rarely. Once Unirest has been activated configuration options that are involved in creating the client cannot be changed without an explicit shutdown or reset.</p>"},{"location":"configuration/#config-options","title":"Config Options","text":"Builder Method Impact Default <code>clientCertificateStore(String,String)</code> Add a PKCS12 KeyStore by path for doing client certificates <code>clientCertificateStore(KeyStore,String)</code> Add a PKCS12 KeyStore for doing client certificates <code>connectTimeout(int)</code> Sets the connection timeout for all requests in millis 10000 <code>connectionTTL(Duration)</code> Add total time to live (TTL) by Duration. Good for moderns Java APIs. -1 <code>connectionTTL(long,TimeUnit)</code> Total time to live (TTL)  defines maximum life span of persistent connections regardless of their expiration setting. No persistent connection will be re-used past its TTL value. -1 <code>cookieSpec(String)</code> set a cookie policy. Acceptable values: 'default' (same as Netscape), 'netscape', 'ignoreCookies', 'standard' (RFC 6265 interoprability profile) , 'standard-strict' (RFC 6265 strict profile) default <code>defaultBaseUrl(String value)</code> Set a default base URL to be used for all requests that do not already contain a scheme <code>disableHostNameVerification(Boolean value)</code> Sets the system property jdk.internal.httpclient.disableHostnameVerification. This will disable host name verification for ALL instances of Unirest or the Java client on the JVM <code>setDefaultHeader(String, String)</code> Sets  a default header. Will overwrite if it exists <code>setDefaultHeader(String, Supplier&lt;String&gt;)</code> Sets a default header by supplier. Good for setting trace tokens for microservice architectures. Will overwrite if it exists <code>addDefaultHeader(String, String)</code> Adds a default header. Multiple for the same name can exist <code>addDefaultHeader(String, Supplier&lt;String&gt;)</code> Add a default header by supplier. Good for setting trace tokens for microservice architectures. <code>setDefaultBasicAuth(String, String)</code> Add a default Basic Auth Header <code>enableCookieManagement(boolean)</code> toggle accepting and storing cookies true <code>errorHandler(Consumer&lt;HttpResponse&lt;?&gt;&gt; consumer)</code> Set a global error handler that will be invoked for any status &gt; 400 or a parsing error <code>followRedirects(boolean)</code> toggle following redirects true <code>interceptor(Interceptor value)</code> Set a global Interceptor handler that will be invoked before and after each request <code>proxy(proxy)</code> Sets a proxy object for negotiating proxy servers. Can include auth credentials <code>requestTimeout(int)</code> Sets the request timeout for all requests in millis none (infinite) <code>retryAfter(boolean)</code> Automatically retry synchronous requests on 429/529 responses with the Retry-After response header false <code>retryAfter(boolean,int)</code> Automatically retry synchronous requests on 429/529 responses with the Retry-After response header as well as number of attempts false <code>verifySsl(boolean)</code> toggle enforcing SSL true"},{"location":"configuration/#global-interceptor","title":"Global Interceptor","text":"<p>You can set a global interceptor for your configuration. This is invoked before and after each request. This can be useful for logging or injecting common attributes.</p> <p>See Interceptor.java for details.</p>"},{"location":"configuration/#multiple-configurations","title":"Multiple Configurations","text":"<p>As usual, Unirest maintains a primary single instance. Sometimes you might want different configurations for different systems. You might also want an instance rather than a static context for testing purposes.</p> <pre><code>    // this returns the same instance used by Unirest.get(\"http://somewhere/\")\n    UnirestInstance unirest = Unirest.primaryInstance();\n    // It can be configured and used just like the static context\n    unirest.config().connectTimeout(5000);\n    String result = unirest.get(\"http://foo\").asString().getBody();\n\n    // You can also get a whole new instance\n    UnirestInstance unirest = Unirest.spawnInstance();\n</code></pre>"},{"location":"configuration/#object-mappers","title":"Object Mappers","text":"<p>Unirest offers a few different Object Mapper's based on popular JSON libraries (Jackson and GSON). <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;com.konghq&lt;/groupId&gt;\n    &lt;artifactId&gt;unirest-modules-jackson&lt;/artifactId&gt;\n&lt;/dependency&gt;\n\n&lt;dependency&gt;\n    &lt;groupId&gt;com.konghq&lt;/groupId&gt;\n    &lt;artifactId&gt;unirest-modules-gson&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre></p> <p>If you have some other need you can supply your own Object mapper by implementing the <code>ObjectMapper</code> interface. It has only a few methods</p>"},{"location":"configuration/#metrics","title":"Metrics","text":"<p>Unirest has hooks for collecting metrics on your runtime code. This is a simple and lightweight framework that marks two events:    1. The moment just before the actual request is made    1. The moment just after the actual request is made</p> <p>Context information like method and request path are given to you so that you can collect based on whatever your needs are. In its simplest form it might look like this:</p> <pre><code>   Unirest.config().instrumentWith(requestSummary -&gt; {\n              long startNanos = System.nanoTime();\n              return (responseSummary,exception) -&gt; logger.info(\"path: {} status: {} time: {}\",\n                      requestSummary.getRawPath(),\n                      responseSummary.getStatus(),\n                      System.nanoTime() - startNanos);\n   });\n</code></pre> <p>By providing more feature rich UniMetric instances you could easily calculate averages per route, uptime, or other fun facts.</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#unirest-4","title":"Unirest 4","text":"<p>Unirest 4 is build on modern Java standards, and as such requires at least Java 11.</p> <p>Unirest 4's dependencies are fully modular, and have been moved to new Maven coordinates to avoid conflicts with the previous versions. You can use a maven bom to manage the modules:</p>"},{"location":"installation/#install-with-maven","title":"Install With Maven:","text":"<pre><code>&lt;dependencyManagement&gt;\n    &lt;dependencies&gt;\n        &lt;!-- https://mvnrepository.com/artifact/com.konghq/unirest-java-bom --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.konghq&lt;/groupId&gt;\n            &lt;artifactId&gt;unirest-java-bom&lt;/artifactId&gt;\n            &lt;version&gt;4.5.1&lt;/version&gt;\n            &lt;type&gt;pom&lt;/type&gt;\n            &lt;scope&gt;import&lt;/scope&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n&lt;/dependencyManagement&gt;\n\n&lt;dependencies&gt;\n&lt;!-- https://mvnrepository.com/artifact/com.konghq/unirest-java-core --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;com.konghq&lt;/groupId&gt;\n    &lt;artifactId&gt;unirest-java-core&lt;/artifactId&gt;\n&lt;/dependency&gt;\n\n&lt;!-- pick a JSON module if you want to parse JSON include one of these: --&gt;\n&lt;!-- Google GSON --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;com.konghq&lt;/groupId&gt;\n    &lt;artifactId&gt;unirest-modules-gson&lt;/artifactId&gt;\n&lt;/dependency&gt;\n\n&lt;!-- OR maybe you like Jackson better? --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;com.konghq&lt;/groupId&gt;\n    &lt;artifactId&gt;unirest-modules-jackson&lt;/artifactId&gt;\n&lt;/dependency&gt;\n&lt;/dependencies&gt;\n</code></pre>"},{"location":"installation/#attention-json-users","title":"\ud83d\udea8 Attention JSON users \ud83d\udea8","text":"<p>Under Unirest 4, core no longer comes with ANY transient dependencies, and because Java itself lacks a JSON parser you MUST declare a JSON implementation if you wish to do object mappings or use Json objects.</p>"},{"location":"installation/#upgrading-from-previous-versions","title":"Upgrading from Previous Versions","text":"<p>See the Upgrade Guide</p>"},{"location":"installation/#changelog","title":"ChangeLog","text":"<p>See the Change Log for recent changes.</p>"},{"location":"installation/#unirest-3","title":"Unirest 3","text":""},{"location":"installation/#maven","title":"Maven","text":"<pre><code>&lt;!-- Pull in as a traditional dependency --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;com.konghq&lt;/groupId&gt;\n    &lt;artifactId&gt;unirest-java&lt;/artifactId&gt;\n    &lt;version&gt;3.14.1&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"mocks/","title":"Unirest Mocks","text":""},{"location":"mocks/#about","title":"About","text":"<p>A series of mocks for use with Unirest for unit testing. Mocked clients will not make any real web requests. This allows you to test the input into unirest and to mock responses from expected requests.</p> <pre><code>    flowchart TD\n        A[Your Code] --&gt; B(Unirest Pubilc Interface)\n        B --&gt; C{Core Implimentation}\n        C --&gt;|When Mocked| D[Mocked Client]\n        C --&gt;|Normal Runtime| F[Java HttpClient]</code></pre>"},{"location":"mocks/#expecting-requests","title":"Expecting Requests","text":"<p>You can either mock the default static implementation or a per instance implementation. In both cases you need to register the mock with Unirest.</p>"},{"location":"mocks/#static-mocking","title":"Static Mocking","text":"<pre><code>class MyTest {\n    @Test\n    void mockStatic(){\n        MockClient mock = MockClient.register();\n\n        mock.expect(HttpMethod.GET, \"http://zombo.com\")\n                        .thenReturn(\"You can do anything!\");\n\n        assertEquals(\n            \"You can do anything!\", \n            Unirest.get(\"http://zombo.com\").asString().getBody()\n        );\n    }\n}\n</code></pre>"},{"location":"mocks/#instant-mocking","title":"Instant Mocking","text":"<pre><code>    @Test\n    void mockInstant(){\n        UnirestInstance unirest = Unirest.spawnInstance();\n        MockClient mock = MockClient.register(unirest);\n\n        mock.expect(HttpMethod.GET, \"http://zombo.com\")\n                        .thenReturn(\"You can do anything!\");\n\n        assertEquals(\n            \"You can do anything!\", \n            unirest.get(\"http://zombo.com\").asString().getBody()\n        );\n    }\n</code></pre>"},{"location":"mocks/#multiple-expects","title":"Multiple Expects","text":"<p>HTTP requests can have many parts, some of which are automatic or at least uninteresting from the standpoint of testing. This means that setting up an exact expectation to match the request exactly can be tedious. </p> <p>You can register as many expects as you like. Which one is used for any particular invocation of Unirest depends on a points system. Each expectation is evaluated and given points for each positive part while any negative part immediately discards the expect. The expectation that has the most points \"wins\".</p> <p>In this example, we have three expectations, one doesn't match at all. and two others match but one does more than the other so the most specific match is used.</p> <pre><code>    @Test\n    void multipleExpects(){\n        MockClient mock = MockClient.register();\n\n        mock.expect(HttpMethod.POST, \"https://somewhere.bad\")\n                .thenReturn(\"I'm Bad\");\n\n        mock.expect(HttpMethod.GET, \"http://zombo.com\")\n                .thenReturn(\"You can do anything!\");\n\n        mock.expect(HttpMethod.GET, \"http://zombo.com\")\n                .header(\"foo\", \"bar\")\n                .thenReturn(\"You can do anything with headers!\");\n\n        assertEquals(\n                \"You can do anything with headers!\",\n                Unirest.get(\"http://zombo.com\")\n                        .header(\"foo\", \"bar\")\n                        .asString().getBody()\n        );\n\n        assertEquals(\n                \"You can do anything!\",\n                Unirest.get(\"http://zombo.com\")\n                        .asString().getBody()\n        );\n    }\n</code></pre>"},{"location":"mocks/#verifying-expects","title":"Verifying Expects","text":"<p>Sometimes we only want to know that the needful was done. In this case we can validate our mock. The simplest way is to call verifyAll which will validate that all expects were called at least once.</p> <pre><code>    @Test\n    void verifyAll(){\n        MockClient mock = MockClient.register();\n\n        mock.expect(HttpMethod.POST, \"http://zombo.com\")\n                .thenReturn().withStatus(200);\n\n        Unirest.post(\"http://zombo.com\").asString().getBody();\n\n        mock.verifyAll();\n    }\n</code></pre> <p>If you want to get more specific we can keep around our expectations and validate them explicitly. We can also inject a number of times we want to validate (including zero) <pre><code>    @Test\n    void verifyMultiple(){\n        MockClient mock = MockClient.register();\n\n        var zombo =    mock.expect(HttpMethod.POST, \"http://zombo.com\").thenReturn();\n        var homestar = mock.expect(HttpMethod.DELETE, \"http://homestarrunner.com\").thenReturn();\n\n        Unirest.post(\"http://zombo.com\").asString().getBody();\n\n        zombo.verify();\n        homestar.verify(Times.never());\n    }\n</code></pre></p>"},{"location":"mocks/#expected-body-matching","title":"Expected Body Matching","text":"<p>You can match specific body content with some limitations. Complex bodies must implement <code>BodyMatcher</code>. There are two implementations available: <code>EqualsBodyMatcher</code> which is used for simple equality and <code>FieldMatcher</code> which is for form params. You can create your own.</p>"},{"location":"mocks/#simple-bodies","title":"Simple Bodies","text":"<pre><code>    @Test\n    void simpleBody() {\n        MockClient mock = MockClient.register();\n\n        mock.expect(HttpMethod.POST, \"http://zombo.com\")\n                .body(\"I can do anything? Anything at all?\")\n                .thenReturn()\n                .withStatus(201);\n\n        assertEquals(201,\n                Unirest.post(\"http://zombo.com\").body(\"I can do anything? Anything at all?\").asEmpty().getStatus()\n        );\n    }\n</code></pre>"},{"location":"mocks/#form-params","title":"Form Params","text":"<pre><code>    @Test\n    void formParams() {\n        MockClient mock = MockClient.register();\n\n        mock.expect(HttpMethod.POST, \"http://zombo.com\")\n                .body(FieldMatcher.of(\"foo\", \"bar\",\n                                      \"baz\", \"qux\"))\n                .thenReturn()\n                .withStatus(201);\n\n        assertEquals(201,\n                Unirest.post(\"http://zombo.com\")\n                        .field(\"foo\", \"bar\")\n                        .field(\"baz\", \"qux\")\n                        .asEmpty().getStatus()\n        );\n    }\n</code></pre>"},{"location":"mocks/#expected-responses","title":"Expected Responses","text":"<p>You can set all properties of a response. <pre><code>    @Test\n    void response() {\n        MockClient mock = MockClient.register();\n\n        mock.expect(HttpMethod.GET, \"http://zombo.com\")\n                .thenReturn(\"Care for some tea mum?\")\n                .withHeader(\"x-zombo-brewing\", \"active\")\n                .withStatus(418, \"I am a teapot\");\n\n        var response = Unirest.get(\"http://zombo.com\").asString();\n\n        assertEquals(418, response.getStatus());\n        assertEquals(\"I am a teapot\", response.getStatusText());\n        assertEquals(\"Care for some tea mum?\", response.getBody());\n        assertEquals(\"active\", response.getHeaders().getFirst(\"x-zombo-brewing\"));\n    }\n</code></pre></p>"},{"location":"mocks/#responses-with-json-bodies","title":"Responses with JSON Bodies","text":"<p>The mocking framework will use whatever ObjectMapper is configured with Unirest to marshall Pojos to expected responses.</p> <pre><code>    static class Teapot { public String brewstatus = \"on\"; }\n    @Test\n    void pojos() {\n        MockClient mock = MockClient.register();\n\n        mock.expect(HttpMethod.GET, \"http://zombo.com\")\n                .thenReturn(new Teapot());\n\n        var response = Unirest.get(\"http://zombo.com\").asString();\n\n        assertEquals(\"{\\\"brewstatus\\\":\\\"on\\\"}\", response.getBody());\n    }\n</code></pre>"},{"location":"requests/","title":"Requests","text":"<p>So you're probably wondering how using Unirest makes creating requests in Java easier, here is a basic POST request that will explain everything:</p> <pre><code>HttpResponse&lt;JsonNode&gt; response = Unirest.post(\"http://localhost/post\")\n      .header(\"accept\", \"application/json\")\n      .queryString(\"apiKey\", \"123\")\n      .field(\"parameter\", \"value\")\n      .field(\"firstname\", \"Gary\")\n      .asJson();\n</code></pre> <p>Requests are made when <code>as[Type]()</code> is invoked, possible types include <code>Json</code>, <code>String</code>, <code>Object</code> <code>Empty</code> and <code>File</code>.</p>"},{"location":"requests/#route-parameters","title":"Route Parameters","text":"<p>Sometimes you want to add dynamic parameters in the URL, you can easily do that by adding a placeholder in the URL, and then by setting the route parameters with the <code>routeParam</code> function, like:</p> <p><pre><code>Unirest.get(\"http://localhost/{fruit}\")\n     .routeParam(\"fruit\", \"apple\")\n     .asString();\n\n// Results in `http://localhost/apple`\n</code></pre> The placeholder <code>{fruit}</code> will be replaced with <code>apple</code>.</p> <p>The placeholder's format is as easy as wrapping in curly braces: <code>{custom_name}</code></p> <p>All param values will be URL-Encoded for you</p>"},{"location":"requests/#default-base-urls","title":"Default Base URLs","text":"<p>You  can configure a default base URL to be used for all requests that do not contain a full URL.</p> <p>This configuration will result in a GET to \"http://homestar.com/runner\" <pre><code>   Unirest.config().defaultBaseUrl(\"http://homestar.com\");\n\n   Unirest.get(\"/runner\").asString();\n</code></pre></p>"},{"location":"requests/#query-parameters","title":"Query Parameters","text":"<p>Query-string params can be built up one by one</p> <pre><code>Unirest.get(\"http://localhost\")\n                .queryString(\"fruit\", \"apple\")\n                .queryString(\"droid\", \"R2D2\")\n                .asString();\n\n// Results in \"http://localhost?fruit=apple&amp;droid=R2D2\"\n</code></pre> <p>Again all param values will be URL-Encoded.</p> <p>You can also pass in query strings as arrays and maps: <pre><code>Unirest.get(\"http://localhost\")\n        .queryString(\"fruit\", Arrays.asList(\"apple\", \"orange\"))\n        .queryString(ImmutableMap.of(\"droid\", \"R2D2\", \"beatle\", \"Ringo\"))\n        .asString();\n\n // Results in \"http://localhost?fruit=apple&amp;fruit=orange&amp;droid=R2D2&amp;beatle=Ringo\"\n</code></pre></p>"},{"location":"requests/#headers","title":"Headers","text":"<p>Request headers can be added with the <code>header</code> method. <pre><code>Unirest.get(\"http://localhost\")\n            .header(\"Accept\", \"application/json\")\n            .header(\"x-custom-header\", \"hello\")\n            .asString();\n</code></pre></p>"},{"location":"requests/#basic-authentication","title":"Basic Authentication","text":"<p>Unirest exposes a shortcut for doing basic auth when you need to. Unirest handles the Base64 encoding part. Please make sure you are always doing this over HTTPS!</p> <pre><code>Unirest.get(\"http://localhost\")\n            .basicAuth(\"user\", \"password1!\")\n            .asString();\n\n// this adds the header \"Authorization: Basic dXNlcjpwYXNzd29yZDEh\"\n</code></pre>"},{"location":"requests/#body-data","title":"Body Data","text":""},{"location":"requests/#entity-bodies","title":"Entity Bodies","text":"<p>You can post entity objects as the full body easily. This is the default behavior of most REST services.</p> <p>Unless you specify otherwise the default <code>Content-Type</code> is <code>text/plain; charset=UTF-8</code></p> <pre><code>Unirest.post(\"http://localhost\")\n                .body(\"This is the entire body\")\n                .asEmpty();\n</code></pre> <p>You can also post as a Object that is serialized using a configured ObjectMapper. (see Object Mappers for implementation details. Unirest comes with a default mapper that will serialize to json using the popular Google Gson library <pre><code>Unirest.post(\"http://localhost\")\n            .header(\"Content-Type\", \"application/json\")\n            .body(new SomeUserObject(\"Bob\"))\n            .asEmpty();\n\n// This will use Jackson to serialize the object into JSON.\n</code></pre></p>"},{"location":"requests/#json-patch-bodies","title":"JSON Patch Bodies","text":"<p>Unirest has full native support for JSON Patch requests (RFC-6902 see http://jsonpatch.com/) Per the spec, the default <code>Content-Type</code> for json-patch is <code>application/json-patch+json</code></p> <p><pre><code>     Unirest.jsonPatch(\"http://localhost\")\n            .add(\"/fruits/-\", \"Apple\")\n            .remove(\"/bugs\")\n            .replace(\"/lastname\", \"Flintstone\")\n            .test(\"/firstname\", \"Fred\")\n            .move(\"/old/location\", \"/new/location\")\n            .copy(\"/original/location\", \"/new/location\")\n            .asJson();\n</code></pre> will send a request with a body of <pre><code>  [\n     {\"op\":\"add\",\"path\":\"/fruits/-\",\"value\":\"Apple\"},\n     {\"op\":\"remove\",\"path\":\"/bugs\"},\n     {\"op\":\"replace\",\"path\":\"/lastname\",\"value\":\"Flintstone\"},\n     {\"op\":\"test\",\"path\":\"/firstname\",\"value\":\"Fred\"},\n     {\"op\":\"move\",\"path\":\"/new/location\",\"from\":\"/old/location\"},\n     {\"op\":\"copy\",\"path\":\"/new/location\",\"from\":\"/original/location\"}\n  ]\n</code></pre></p>"},{"location":"requests/#basic-forms","title":"Basic Forms","text":"<p>Basic http name value body params can be passed with simple field calls. The <code>Content-Type</code> for this type of request is defaulted to  <code>application/x-www-form-urlencoded</code></p> <pre><code>Unirest.post(\"http://localhost\")\n       .field(\"fruit\", \"apple\")\n       .field(\"droid\", \"R2D2\")\n       .asEmpty();\n\n  // This will post a simple name-value pair body the same as a HTML form. This looks like\n  // `fruit=apple&amp;droid=R2D2'\n</code></pre>"},{"location":"requests/#file-uploads","title":"File Uploads","text":"<p>You can also post binary data in a form. Like a file.</p> <p>The <code>Content-Type</code> for this type of request is defaulted to  <code>multipart/form-data</code></p> <pre><code>Unirest.post(\"http://localhost\")\n       .field(\"upload\", new File(\"/MyFile.zip\"))\n       .asEmpty();\n</code></pre> <p>For large files you may want to use a InputStream. Pass it a file name if you want one. We are using a FileInputStream here but it can actually be any kind of InputStream.</p> <pre><code>InputStream file = new FileInputStream(new File(\"/MyFile.zip\"));\n\nUnirest.post(\"http://localhost\")\n       .field(\"upload\", file, \"MyFile.zip\")\n       .asEmpty();\n</code></pre>"},{"location":"requests/#upload-progress-monitoring","title":"Upload Progress Monitoring","text":"<p>If you are uploading large files you might want to provide some time of progress bar to a user. You can monitor this progress by providing a ProgresMonitor.</p> <pre><code>          Unirest.post(\"http://localhost\")\n                .field(\"upload\", new File(\"/MyFile.zip\"))\n                .uploadMonitor((field, fileName, bytesWritten, totalBytes) -&gt; {\n                    updateProgressBarWithBytesLeft(totalBytes - bytesWritten);\n                })\n                .asEmpty();\n</code></pre>"},{"location":"requests/#asynchronous-requests","title":"Asynchronous Requests","text":"<p>Sometimes, well most of the time, you want your application to be asynchronous and not block, Unirest supports this in Java using anonymous callbacks, or direct method placement. All request types also support async versions.</p> <pre><code>CompletableFuture&lt;HttpResponse&lt;JsonNode&gt;&gt; future = Unirest.post(\"http://localhost/post\")\n  .header(\"accept\", \"application/json\")\n  .field(\"param1\", \"value1\")\n  .field(\"param2\", \"value2\")\n  .asJsonAsync(response -&gt; {\n        int code = response.getStatus();\n        JsonNode body = response.getBody();\n    });\n</code></pre>"},{"location":"requests/#paged-requests","title":"Paged Requests","text":"<p>Sometimes services offer paged requests. How this is done is not standardized but Unirest proves a mechanism to follow pages until all have been consumed. You must provide two functions for extracting the next page. The first is to get the HttpResponse in the format you want, the other is to extract the <code>next</code> link from the response. The result is a <code>PagedList</code> of <code>HttpResponse&lt;T&gt;</code>. The paged list has some handy methods for dealing with the results. Here we are getting a paged list of Dogs where the <code>next</code> link is in the headers.</p> <pre><code>PagedList&lt;Doggos&gt; result =  Unirest.get(\"https://somewhere/dogs\")\n                .asPaged(\n                        r -&gt; r.asObject(Doggos.class),\n                        r -&gt; r.getHeaders().getFirst(\"nextPage\")\n                );\n</code></pre>"},{"location":"requests/#client-certificates","title":"Client Certificates","text":"<p>In case you need to use a custom client certificate to call a service you can provide unirest with a custom keystore. You may either pass a KeyStore object or a path to a valid PKCS#12 keystore file.</p> <pre><code>Unirest.config()\n  .clientCertificateStore(\"/path/mykeystore.p12\", \"password1!\");\n\nUnirest.get(\"https://some.custom.secured.place.com\")\n                .asString();\n</code></pre>"},{"location":"requests/#proxies","title":"Proxies","text":"<p>Sometimes you need to tunnel through a proxy. Unirest can be configured to do this. Note that authenticated proxies cannot be configured on a per-request basis unless you want to build it into the URL itself.</p> <pre><code>    // Configure with authentication:\n    Unirest.config().proxy(\"proxy.com\", 7777, \"username\", \"password1!\");\n\n    // or without\n    Unirest.config().proxy(\"proxy.com\", 7777);\n\n    // or pass it in the request. This will override any proxy done in the config\n    // currently only unauthenticated proxies work\n    Unirest.get(MockServer.GET)\n                    .proxy(\"proxy.com\", 7777)\n                    .asString();\n</code></pre>"},{"location":"responses/","title":"Responses","text":"<p>Unirest makes the actual request the moment you invoke of it's <code>as[type]</code> method. These methods also inform Unirest what type to map the response to. Options are <code>Empty</code>, <code>String</code>, <code>File</code>, <code>Object</code>, <code>byte</code> and <code>Json</code>.</p> <p>The response returns as a <code>HttpResponse&lt;T&gt;</code> where the <code>HttpResponse</code> object has all of the common response data like status and headers. The Body (if present) can be accessed via the desired type with the <code>.getBody()</code> method. </p>"},{"location":"responses/#empty-responses","title":"Empty Responses","text":"<p>If you aren't expecting a body back, <code>asEmpty</code> is the easiest choice. You will still get back response information like status and headers.</p> <pre><code>HttpResponse response = Unirest.delete(\"http://localhost\").asEmpty()\n</code></pre>"},{"location":"responses/#string-responses","title":"String Responses","text":"<p>The next easiest response type is String. You can do whatever you want with it after that.</p> <pre><code>String body = Unirest.get(\"http://localhost\")\n                     .asString()\n                     .getBody();\n</code></pre>"},{"location":"responses/#object-mapped-responses","title":"Object Mapped Responses","text":"<p>Most of the time when consuming RESTful services you probably want to map the response into an object. </p> <p>For this you need to provide the Unirest configuration with a implementation of <code>ObjectMapper</code> (see Object Mappers for details.).</p> <p>If the response is JSON you are in luck and Unirest comes with a basic <code>JsonObjectMapper</code> basic on Google GSON  </p> <p>Before an <code>asObject(Class)</code> it is necessary to provide a custom implementation of the <code>ObjectMapper</code> interface (if you do not wish to use the default mapper). This should be done only the first time, as the instance of the ObjectMapper will be shared globally.</p> <p>Unirest offers a few plug-ins implementing popular object mappers like Jackson and Gson. See mvn central for details.</p> <p>For example,  <pre><code>// Response to Object\nBook book = Unirest.get(\"http://localhost/books/1\")\n                   .asObject(Book.class)\n                   .getBody();\n\n// Generic types can be resolved by using a GenericType subclass to avoid erasure\nList&lt;Book&gt; books = Unirest.get(\"http://localhost/books/\")\n              .asObject(new GenericType&lt;List&lt;Book&gt;&gt;(){})\n              .getBody();\n\nAuthor author = Unirest.get(\"http://localhost/books/{id}/author\")\n                       .routeParam(\"id\", bookObject.getId())\n                       .asObject(Author.class)\n                       .getBody();\n</code></pre></p>"},{"location":"responses/#errors-in-object-or-json-parsing","title":"Errors in Object or JSON parsing","text":"<p>You can't always get what you want. And sometimes results you get from web services will not map into what you expect them to. When this happens with a <code>asObject</code> or <code>asJson</code> request the resulting body will be null, but the response object will contain a ParsingException that allows you to get the error and the original body for inspection.</p> <pre><code>UnirestParsingException ex = response.getParsingError().get();\n\nex.getOriginalBody(); // Has the original body as a string.\nex.getMessage(); // Will have the parsing exception.\nex.getCause(); // of course will have the original parsing exception itself.\n</code></pre>"},{"location":"responses/#mapping-error-objects","title":"Mapping Error Objects","text":"<p>Sometimes with REST API's the service will return a error object that can be parsed. You can optionally map this into an POJO like</p> <pre><code>    HttpResponse&lt;Book&gt; book = Unirest.get(\"http://localhost/books/{id}\")\n                                     .asObject(Book.class);\n\n    // This will be null if there wasn't an error\n    Error er = book.mapError(Error.class);\n\n    // You can also take advantage of this inside of the ifFailure method\n    Unirest.get(\"http://localhost/books/{id}\")\n           .asObject(Book.class)\n           .ifFailure(Error.class, r -&gt; {\n                    Error e = r.getBody();\n           });\n</code></pre>"},{"location":"responses/#mapping-one-body-type-to-another-without-an-object-mapper","title":"Mapping one body type to another without an object mapper","text":"<p>If you don't want to provide a full ObjectMapper implementation you may  use  a simple function to map the response</p> <pre><code>    int body = Unirest.get(\"http://httpbin/count\")\n                      .asString()\n                      .mapBody(Integer::valueOf);\n</code></pre>"},{"location":"responses/#file-responses","title":"File Responses","text":"<p>Sometimes you just want to download a file, or maybe capture the response body into a file. Unirest can do both. Just tell Unirest where you want to put the file.</p> <pre><code>File result = Unirest.get(\"http://some.file.location/file.zip\")\n                .asFile(\"/disk/location/file.zip\")\n                .getBody();\n</code></pre>"},{"location":"responses/#download-progress-monitoring","title":"Download Progress Monitoring","text":"<p>If you are uploading large files you might want to provide some time of progress bar to a user. You can monitor this progress by providing a ProgresMonitor.</p> <pre><code>          Unirest.get(\"http://localhost\")\n                .downLoadMonitor((b, fileName, bytesWritten, totalBytes) -&gt; {\n                    updateProgressBarWithBytesLeft(totalBytes - bytesWritten);\n                })\n                .asFile(\"/disk/location/file.zip\");\n</code></pre>"},{"location":"responses/#json-responses","title":"JSON responses","text":"<p>Unirest offers a lightweight JSON response type when you don't need a full Object Mapper.</p> <pre><code>String result = Unirest.get(\"http://some.json.com\")\n                       .asJson()\n                       .getBody()\n                       .getObject()\n                       .getJSONObject(\"car\")\n                       .getJSONArray(\"wheels\")\n                       .get(0)\n</code></pre>"},{"location":"responses/#large-responses","title":"Large Responses","text":"<p>Some response methods (<code>asString</code>, <code>asJson</code>) read the entire response stream into memory. In order to read the original stream and handle large responses you can use several functional methods like:</p> <pre><code>   Map r = Unirest.get(MockServer.GET)\n                .queryString(\"firstname\", \"Gary\")\n                .asObject(i -&gt; new Gson().fromJson(i.getContentReader(), HashMap.class))\n                .getBody();\n</code></pre> <p>or consumers:</p> <pre><code>         Unirest.get(MockServer.GET)\n                .thenConsumeAsync(r -&gt; {\n                       // something like writing a file to disk\n                });\n</code></pre>"},{"location":"responses/#error-handling","title":"Error Handling","text":"<p>the HttpResponse object has a few handler methods that can be chained to deal with success and failure:    * <code>ifSuccess(Consumer&lt;HttpResponse&lt;T&gt;&gt; response)</code> will be called if the response was a 200-series response and any body processing (like <code>json</code> or <code>Object</code> was successful.    * <code>ifFailure(Consumer&lt;HttpResponse&gt; response</code> will be called if the status was 400+ or body processing failed.</p> <p>Putting them together might look like this: <pre><code>         Unirest.get(\"http://somewhere\")\n                .asJson()\n                .ifSuccess(response -&gt; someSuccessMethod(response))\n                .ifFailure(response -&gt; {\n                    log.error(\"Oh No! Status\" + response.getStatus());\n                    response.getParsingError().ifPresent(e -&gt; {\n                        log.error(\"Parsing Exception: \", e);\n                        log.error(\"Original body: \" + e.getOriginalBody());\n                    });\n                });\n</code></pre></p>"},{"location":"server-sent-events/","title":"Server Sent Events","text":""},{"location":"server-sent-events/#about-server-sent-events","title":"About Server Sent Events","text":"<p>Server-Sent Events (SSE) is a server push technology enabling a client to receive automatic updates from a server via an HTTP connection, and describes how servers can initiate data transmission towards clients once an initial client connection has been established. They are commonly used to send message updates or continuous data streams to a browser client and designed to enhance native, cross-browser streaming through a JavaScript API called EventSource, through which a client requests a particular URL in order to receive an event stream. The EventSource API is standardized as part of HTML Living Standard by the WHATWG.  The default media type for SSE is <code>text/event-stream</code>.</p>"},{"location":"server-sent-events/#consuming-server-sent-events-with-unirest-java","title":"Consuming Server Sent Events With Unirest-Java","text":"<p>Unirest has two ways to consume a SSE web service; one async and one synchronous. Please be mindful that SSE is a persistent connection and unirest will keep the connection open as long as the server is willing and able. For this reason you may find the async method a better fit for most production systems. </p> <p>NOTE: In order for object mapping to occur you must configure an ObjectMapper with unirest.</p>"},{"location":"server-sent-events/#async-call","title":"Async Call","text":"<p>The following subscribes to wikipedia's SSE stream of recently changed pages. Maps each event into a POJO, and outputs the name of the changed page. Note that Unirest will return you a <code>CompletableFuture&lt;Void&gt;</code> which you can hold on to to monitor the process. <pre><code>     var future = Unirest.sse(\"https://stream.wikimedia.org/v2/stream/recentchange\")\n        .connect(event -&gt; {\n            var change = event.asObject(RecentChange.class);\n            System.out.println(\"Changed Page: \" + change.getTitle());\n        });\n</code></pre></p>"},{"location":"server-sent-events/#synchronous-call","title":"Synchronous Call","text":"<p>The following subscribes to wikipedia's SSE stream of recently changed pages. Maps each event into a POJO, and outputs the name of the changed page. <pre><code>     Unirest.sse(\"https://stream.wikimedia.org/v2/stream/recentchange\")\n                    .connect()\n                    .map(event -&gt; event.asObject(RecentChange.class))\n                    .forEach(change -&gt; System.out.println(\"Changed Page: \" + change.getTitle()));\n</code></pre></p>"},{"location":"upgrade-guide/","title":"Upgrade Guide","text":""},{"location":"upgrade-guide/#upgrading-to-unirest-43","title":"Upgrading to Unirest 4.3","text":"<p>The modules have been repackaged and put into new maven coordinates in order to avoid conflicts with the 3.x line of unirest. The mock module has had its maven artifact ID changed only.</p> Old Maven Artifact ID New Maven Artifact ID Old Class Package New Class Package unirest-object-mappers-gson unirest-modules-gson kong.unirest.gson kong.unirest.modules.gson unirest-objectmapper-jackson unirest-modules-jackson kong.unirest.jackson kong.unirest.modules.jackson unirest-mocks unirest-modules-mocks kong.unirest.core kong.unirest.core"},{"location":"upgrade-guide/#upgrading-to-unirest-40","title":"Upgrading to Unirest 4.0","text":"<p>\ud83d\udea8 Unirest 4 drops the Apache Http Client dependency in favor of the pure Java client \ud83d\udea8. This means that unirest 4 has a dependency on Java-11. Unirest 3 will continue to be supported for bugs and minor features. If you still haven't upgraded from Java 8 now is the time!  </p> <p>Due to engine changes there are some differences in behavior. Efforts have been made to limit these changes. The others are documented here.</p>"},{"location":"upgrade-guide/#how-to-upgrade","title":"How to upgrade","text":"<ul> <li>The core Unirest package has been moved from <code>kong.unirest</code> to <code>kong.unirest.core</code>, this prevents classloader issues where Unirest 4 may conflict with previous versions which may also be on the classpath.</li> <li>Unirest no longer comes with GSON as a default JSON parser. In order to enable JSON support you must include either the GSON or Jackson JSON packages with: <pre><code>&lt;dependency&gt;\n  &lt;groupId&gt;com.konghq&lt;/groupId&gt;\n  &lt;artifactId&gt;unirest-object-mappers-gson&lt;/artifactId&gt;\n  &lt;version&gt;4.2.4&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;!-- or --&gt;\n&lt;dependency&gt;\n  &lt;groupId&gt;com.konghq&lt;/groupId&gt;\n  &lt;artifactId&gt;unirest-objectmapper-jackson&lt;/artifactId&gt;\n  &lt;version&gt;4.2.4&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre></li> <li>In order to assist with the various modules Unirest now includes a dependency management BOM. Include the BOM in your dependency management section and then just declare the modules you want without the version.</li> </ul> <pre><code>&lt;dependencyManagement&gt;\n  &lt;dependencies&gt;\n      &lt;dependency&gt;\n          &lt;groupId&gt;com.konghq&lt;/groupId&gt;\n          &lt;artifactId&gt;unirest-java-bom&lt;/artifactId&gt;\n          &lt;version&gt;4.2.4&lt;/version&gt;\n          &lt;type&gt;pom&lt;/type&gt;\n          &lt;scope&gt;import&lt;/scope&gt;\n      &lt;/dependency&gt;\n  &lt;/dependencies&gt;\n&lt;/dependencyManagement&gt;\n\n&lt;dependencies&gt;\n  &lt;dependency&gt;\n    &lt;groupId&gt;com.konghq&lt;/groupId&gt;\n    &lt;artifactId&gt;unirest-core&lt;/artifactId&gt;\n  &lt;/dependency&gt;\n  &lt;dependency&gt;\n    &lt;groupId&gt;com.konghq&lt;/groupId&gt;\n    &lt;artifactId&gt;unirest-object-mappers-gson&lt;/artifactId&gt;\n  &lt;/dependency&gt;\n&lt;/dependencies&gt;\n</code></pre>"},{"location":"upgrade-guide/#differences","title":"Differences","text":"<ul> <li>null header values are now represented by an empty string rather than null.</li> <li>response headers may return a different order that with Apache.</li> <li>You may not normally override the <code>host</code> header anymore. Starting with Java-12 you may only due this by setting a system property of jdk.httpclient.allowRestrictedHeaders=host. see https://bugs.openjdk.java.net/browse/JDK-8213696</li> <li>Cookie management follows more modern standards and may differ from apache with regard to non-standard parsing. </li> <li>related: <code>config.cookieSpec(String)</code> has been removed as it was Apache specific.</li> <li>Per-Request proxies are no longer supported.  </li> <li>Custom HostNameVerifier is no longer supported.</li> <li>Socket timeout is no longer set independent of connection timeout and has been removed</li> <li>There are no longer any monitoring threads to shut down, as such, all close methods and the registering of shutdown hooks have been removed.</li> <li>Using system props for proxy settings is false by default (was true in previous versions)</li> <li>max concurrent routes is no longer supported as this was a feature of Apache. concurrency(int, int) has been removed.</li> </ul>"},{"location":"upgrade-guide/#upgrading-to-unirest-30","title":"Upgrading to Unirest 3.0","text":"<p>The primary difference in Unirest 3 is that the org.json dependency has been replaced by a clean-room implementation of org.json's interface using Google Gson as the engine. </p>"},{"location":"upgrade-guide/#what-why","title":"What? Why?","text":"<p>This was done due to conflicts with the org.json license which requires that \"The Software shall be used for Good, not Evil.\". While many people would rightly view this as silly and unenforceable by law, many organizations such as Eclipse, Debian, and Apache will not allow using it.</p>"},{"location":"upgrade-guide/#why-not-switch-to-the-google-implementation-of-orgjson","title":"Why not switch to the google implementation of org.json?","text":"<p>Several reasons: * It has not been maintained in several years and no longer matches the org.json signatures. * It causes classpath conflicts which many projects forbid. * We would like Unirest to be able to expand beyond org.json and offer more advanced native features like object mapping.</p>"},{"location":"upgrade-guide/#why-gson-and-not-jackson","title":"Why Gson and not Jackson?","text":"<ul> <li>Gson is closest in spirit and method signature to org.json and was deemed quicker to adopt.</li> <li>It's small, mature and a single dependency. </li> <li>It would conflict less in other projects than Jackson would which is both more popular and far more complex.</li> </ul>"},{"location":"upgrade-guide/#how-was-this-done","title":"How was this done?","text":"<p>Implementation was done without looking at the internals of the org.json classes. This was accomplished by  writing extensive unit tests in order to document behavior and method signatures and then simply changing the test to use this projects own classes as well as Google Gson.</p>"},{"location":"upgrade-guide/#differences-between-orgjson-and-kongunirestcorejson","title":"Differences between org.json and kong.unirest.core.json","text":"<ul> <li>The namespace is now <code>kong.unirest.core.json</code></li> <li>For the most part kong.unirest.core.json honors all public interfaces and behavior of <code>JSONArray</code>, <code>JSONObject</code>, and <code>JSONPointer</code>. </li> <li>The utility classes in org.json have NOT been implemented as they are not required for Unirest's use case. So things like XML-to-JSON, and CSV-to-JSON have not been implemented.</li> <li>Custom indenting with <code>.toString(int spaces)</code> does not honor the indent factor and always uses 2 spaces. Waiting on https://github.com/google/gson/pull/1280 for a fix.</li> <li>There are some slight differences in the details of some error messages.</li> </ul>"},{"location":"upgrade-guide/#upgrading-to-unirest-20-from-previous-versions","title":"Upgrading to Unirest 2.0 from previous versions","text":""},{"location":"upgrade-guide/#package","title":"Package","text":"<p>All main classes are now in the <code>kong.unirest</code> package. Classes related to the underlying Apache Http client that powers unirest are kept in <code>kong.unirest.apache</code> This project doesn't have many files, it really doesn't need anything more complicated than that.</p>"},{"location":"upgrade-guide/#removed-methods-and-java-requirements","title":"Removed Methods and Java Requirements","text":"<ul> <li>Java 8: Java 8 is now required for Unirest due to extensive lambda support.</li> <li><code>.asBinary()</code> and <code>.getRawResponse()</code>  methods have been removed. These have been replaced by consumer methods which allow you to read the InputStream directly and not a copy. (see <code>HttpRequest::thenConsume(Consumer&lt;RawResponse&gt; consumer)</code></li> <li>Removal of all Apache classes in the non-config interfaces. These have ben replaced by Unirest native interfaces.   Typically these interfaces are very similar to the older Apache classes and so updating shouldn't be a problem.</li> </ul>"},{"location":"upgrade-guide/#configuration","title":"Configuration","text":"<p>Previous versions of unirest had configuration split across several different places. </p> <pre><code>   // Sometimes it was on Unirest\n    Unirest.setTimeouts(5000, 10000);\n\n   //Sometimes it was on Options\n   Options.setOption(HTTPCLIENT, client);\n</code></pre> <p>Often you could do it in both places with different impacts on the lifecycle of the client. All configuration has now been centralized in <code>Unirest.config()</code></p>"},{"location":"upgrade-guide/#unirestconfig","title":"Unirest.config()","text":"<p>Unirest config allows easy access to build a configuration just like you would build a request:</p> <pre><code>    Unirest.config()\n           .connectTimeout(1000)\n           .proxy(new Proxy(\"https://proxy\"))\n           .setDefaultHeader(\"Accept\", \"application/json\")\n           .followRedirects(false)\n           .enableCookieManagement(false)\n           .addInterceptor(new MyCustomInterceptor());\n</code></pre>"},{"location":"upgrade-guide/#changing-the-config","title":"Changing the config","text":"<p>Changing Unirest's config should ideally be done once, or rarely. There are several background threads spawned by both Unirest itself and Apache HttpAsyncClient. Once Unirest has been activated configuration options that are involved in creating the client cannot be changed without an explicit shutdown or reset.</p> <pre><code>     Unirest.config()\n            .reset()\n            .connectTimeout(5000)\n</code></pre>"},{"location":"upgrade-guide/#setting-custom-apache-client","title":"Setting custom Apache Client","text":"<p>You can set your own custom Apache HttpClient and HttpAsyncClient. Note that Unirest settings like timeouts or interceptors are not applied to custom clients.</p> <pre><code>     Unirest.config()\n            .httpClient(myClient)\n            .asyncClient(myAsyncClient)\n</code></pre>"},{"location":"upgrade-guide/#multiple-configuration-instances","title":"Multiple Configuration Instances","text":"<p>As usual, Unirest maintains a primary single instance. Sometimes you might want different configurations for different systems. You might also want an instance rather than a static context for testing purposes.</p> <pre><code>    // this returns the same instance used by Unirest.get(\"http://somewhere/\")\n    UnirestInstance unirest = Unirest.primaryInstance(); \n    // It can be configured and used just like the static context\n    unirest.config().connectTimeout(5000);\n    String result = unirest.get(\"http://foo\").asString().getBody();\n\n    // You can also get a whole new instance\n    UnirestInstance unirest = Unirest.spawnInstance();\n</code></pre> <p>WARNING! If you get a new instance of unirest YOU are responsible for shutting it down when the JVM shuts down. It is not tracked or shut down by <code>Unirest.shutDown();</code></p>"}]}